import{c_ as Xt,c$ as Dt,d0 as Wt,d1 as It,d2 as Qt,d3 as Zt,d4 as lt,d5 as kt,d6 as Ct,d7 as nt,d8 as dt,d9 as Jt,da as yt,db as P,dc as rt,dd as bt,de as qt,df as Et,dg as te,dh as Nt,di as ct,dj as Mt,dk as ee,dl as ne,dm as at,dn as re,dp as oe,R as ie}from"./index-BUOZtvET.js";class jt extends Xt{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Dt(e);const r=Wt(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,c=new Uint8Array(s);c.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<c.length;a++)c[a]^=54;this.iHash.update(c),this.oHash=e.create();for(let a=0;a<c.length;a++)c[a]^=106;this.oHash.update(c),c.fill(0)}update(e){return It(this),this.iHash.update(e),this}digestInto(e){It(this),Qt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:c,blockLen:a,outputLen:f}=this;return e=e,e.finished=s,e.destroyed=c,e.blockLen=a,e.outputLen=f,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Vt=(n,e,t)=>new jt(n,e).update(t).digest();Vt.create=(n,e)=>new jt(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const k=BigInt(0),R=BigInt(1),Q=BigInt(2),se=BigInt(3),Bt=BigInt(4),At=BigInt(5),Ot=BigInt(8);function _(n,e){const t=n%e;return t>=k?t:e+t}function ce(n,e,t){if(e<k)throw new Error("invalid exponent, negatives unsupported");if(t<=k)throw new Error("invalid modulus");if(t===R)return k;let r=R;for(;e>k;)e&R&&(r=r*n%t),n=n*n%t,e>>=R;return r}function Y(n,e,t){let r=n;for(;e-- >k;)r*=r,r%=t;return r}function vt(n,e){if(n===k)throw new Error("invert: expected non-zero number");if(e<=k)throw new Error("invert: expected positive modulus, got "+e);let t=_(n,e),r=e,s=k,c=R;for(;t!==k;){const f=r/t,o=r%t,l=s-c*f;r=t,t=o,s=c,c=l}if(r!==R)throw new Error("invert: does not exist");return _(s,e)}function ae(n){const e=(n-R)/Q;let t,r,s;for(t=n-R,r=0;t%Q===k;t/=Q,r++);for(s=Q;s<n&&ce(s,e,n)!==n-R;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const a=(n+R)/Bt;return function(o,l){const B=o.pow(l,a);if(!o.eql(o.sqr(B),l))throw new Error("Cannot find square root");return B}}const c=(t+R)/Q;return function(f,o){if(f.pow(o,e)===f.neg(f.ONE))throw new Error("Cannot find square root");let l=r,B=f.pow(f.mul(f.ONE,s),t),z=f.pow(o,c),w=f.pow(o,t);for(;!f.eql(w,f.ONE);){if(f.eql(w,f.ZERO))return f.ZERO;let S=1;for(let m=f.sqr(w);S<l&&!f.eql(m,f.ONE);S++)m=f.sqr(m);const N=f.pow(B,R<<BigInt(l-S-1));B=f.sqr(N),z=f.mul(z,N),w=f.mul(w,B),l=S}return z}}function fe(n){if(n%Bt===se){const e=(n+R)/Bt;return function(r,s){const c=r.pow(s,e);if(!r.eql(r.sqr(c),s))throw new Error("Cannot find square root");return c}}if(n%Ot===At){const e=(n-At)/Ot;return function(r,s){const c=r.mul(s,Q),a=r.pow(c,e),f=r.mul(s,a),o=r.mul(r.mul(f,Q),a),l=r.mul(f,r.sub(o,r.ONE));if(!r.eql(r.sqr(l),s))throw new Error("Cannot find square root");return l}}return ae(n)}const le=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function de(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=le.reduce((r,s)=>(r[s]="function",r),e);return dt(n,t)}function ue(n,e,t){if(t<k)throw new Error("invalid exponent, negatives unsupported");if(t===k)return n.ONE;if(t===R)return e;let r=n.ONE,s=e;for(;t>k;)t&R&&(r=n.mul(r,s)),s=n.sqr(s),t>>=R;return r}function he(n,e){const t=new Array(e.length),r=e.reduce((c,a,f)=>n.is0(a)?c:(t[f]=c,n.mul(c,a)),n.ONE),s=n.inv(r);return e.reduceRight((c,a,f)=>n.is0(a)?c:(t[f]=n.mul(c,t[f]),n.mul(c,a)),s),t}function _t(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Ut(n,e,t=!1,r={}){if(n<=k)throw new Error("invalid field: expected ORDER > 0, got "+n);const{nBitLength:s,nByteLength:c}=_t(n,e);if(c>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const f=Object.freeze({ORDER:n,isLE:t,BITS:s,BYTES:c,MASK:kt(s),ZERO:k,ONE:R,create:o=>_(o,n),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return k<=o&&o<n},is0:o=>o===k,isOdd:o=>(o&R)===R,neg:o=>_(-o,n),eql:(o,l)=>o===l,sqr:o=>_(o*o,n),add:(o,l)=>_(o+l,n),sub:(o,l)=>_(o-l,n),mul:(o,l)=>_(o*l,n),pow:(o,l)=>ue(f,o,l),div:(o,l)=>_(o*vt(l,n),n),sqrN:o=>o*o,addN:(o,l)=>o+l,subN:(o,l)=>o-l,mulN:(o,l)=>o*l,inv:o=>vt(o,n),sqrt:r.sqrt||(o=>(a||(a=fe(n)),a(f,o))),invertBatch:o=>he(f,o),cmov:(o,l,B)=>B?l:o,toBytes:o=>t?Zt(o,c):lt(o,c),fromBytes:o=>{if(o.length!==c)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+o.length);return t?Ct(o):nt(o)}});return Object.freeze(f)}function Yt(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function Kt(n){const e=Yt(n);return e+Math.ceil(e/2)}function we(n,e,t=!1){const r=n.length,s=Yt(e),c=Kt(e);if(r<16||r<c||r>1024)throw new Error("expected "+c+"-1024 bytes of input, got "+r);const a=t?Ct(n):nt(n),f=_(a,e-R)+R;return t?Zt(f,s):lt(f,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Lt=BigInt(0),ft=BigInt(1);function wt(n,e){const t=e.negate();return n?t:e}function Pt(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function gt(n,e){Pt(n,e);const t=Math.ceil(e/n)+1,r=2**(n-1);return{windows:t,windowSize:r}}function ge(n,e){if(!Array.isArray(n))throw new Error("array expected");n.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})}function me(n,e){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}const mt=new WeakMap,$t=new WeakMap;function pt(n){return $t.get(n)||1}function pe(n,e){return{constTimeNegate:wt,hasPrecomputes(t){return pt(t)!==1},unsafeLadder(t,r,s=n.ZERO){let c=t;for(;r>Lt;)r&ft&&(s=s.add(c)),c=c.double(),r>>=ft;return s},precomputeWindow(t,r){const{windows:s,windowSize:c}=gt(r,e),a=[];let f=t,o=f;for(let l=0;l<s;l++){o=f,a.push(o);for(let B=1;B<c;B++)o=o.add(f),a.push(o);f=o.double()}return a},wNAF(t,r,s){const{windows:c,windowSize:a}=gt(t,e);let f=n.ZERO,o=n.BASE;const l=BigInt(2**t-1),B=2**t,z=BigInt(t);for(let w=0;w<c;w++){const S=w*a;let N=Number(s&l);s>>=z,N>a&&(N-=B,s+=ft);const m=S,i=S+Math.abs(N)-1,u=w%2!==0,p=N<0;N===0?o=o.add(wt(u,r[m])):f=f.add(wt(p,r[i]))}return{p:f,f:o}},wNAFUnsafe(t,r,s,c=n.ZERO){const{windows:a,windowSize:f}=gt(t,e),o=BigInt(2**t-1),l=2**t,B=BigInt(t);for(let z=0;z<a;z++){const w=z*f;if(s===Lt)break;let S=Number(s&o);if(s>>=B,S>f&&(S-=l,s+=ft),S===0)continue;let N=r[w+Math.abs(S)-1];S<0&&(N=N.negate()),c=c.add(N)}return c},getPrecomputes(t,r,s){let c=mt.get(r);return c||(c=this.precomputeWindow(r,t),t!==1&&mt.set(r,s(c))),c},wNAFCached(t,r,s){const c=pt(t);return this.wNAF(c,this.getPrecomputes(c,t,s),r)},wNAFCachedUnsafe(t,r,s,c){const a=pt(t);return a===1?this.unsafeLadder(t,r,c):this.wNAFUnsafe(a,this.getPrecomputes(a,t,s),r,c)},setWindowSize(t,r){Pt(r,e),$t.set(t,r),mt.delete(t)}}}function ye(n,e,t,r){if(ge(t,n),me(r,e),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const s=n.ZERO,c=Jt(BigInt(t.length)),a=c>12?c-3:c>4?c-2:c?2:1,f=(1<<a)-1,o=new Array(f+1).fill(s),l=Math.floor((e.BITS-1)/a)*a;let B=s;for(let z=l;z>=0;z-=a){o.fill(s);for(let S=0;S<r.length;S++){const N=r[S],m=Number(N>>BigInt(z)&BigInt(f));o[m]=o[m].add(t[S])}let w=s;for(let S=o.length-1,N=s;S>0;S--)N=N.add(o[S]),w=w.add(N);if(B=B.add(w),z!==0)for(let S=0;S<a;S++)B=B.double()}return B}function Ft(n){return de(n.Fp),dt(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({..._t(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ht(n){n.lowS!==void 0&&ct("lowS",n.lowS),n.prehash!==void 0&&ct("prehash",n.prehash)}function be(n){const e=Ft(n);dt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=e;if(t){if(!r.eql(s,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Ee,hexToBytes:Be}=ee;class ve extends Error{constructor(e=""){super(e)}}const F={Err:ve,_tlv:{encode:(n,e)=>{const{Err:t}=F;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const r=e.length/2,s=at(r);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const c=r>127?at(s.length/2|128):"";return at(n)+c+s+e},decode(n,e){const{Err:t}=F;let r=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==n)throw new t("tlv.decode: wrong tlv");const s=e[r++],c=!!(s&128);let a=0;if(!c)a=s;else{const o=s&127;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(r,r+o);if(l.length!==o)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const B of l)a=a<<8|B;if(r+=o,a<128)throw new t("tlv.decode(long): not minimal encoding")}const f=e.subarray(r,r+a);if(f.length!==a)throw new t("tlv.decode: wrong value length");return{v:f,l:e.subarray(r+a)}}},_int:{encode(n){const{Err:e}=F;if(n<G)throw new e("integer: negative integers are not allowed");let t=at(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=F;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Ee(n)}},toSig(n){const{Err:e,_int:t,_tlv:r}=F,s=typeof n=="string"?Be(n):n;ne(s);const{v:c,l:a}=r.decode(48,s);if(a.length)throw new e("invalid signature: left bytes after parsing");const{v:f,l:o}=r.decode(2,c),{v:l,l:B}=r.decode(2,o);if(B.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(f),s:t.decode(l)}},hexFromSig(n){const{_tlv:e,_int:t}=F,r=e.encode(2,t.encode(n.r)),s=e.encode(2,t.encode(n.s)),c=r+s;return e.encode(48,c)}},G=BigInt(0),Z=BigInt(1);BigInt(2);const zt=BigInt(3);BigInt(4);function xe(n){const e=be(n),{Fp:t}=e,r=Ut(e.n,e.nBitLength),s=e.toBytes||((m,i,u)=>{const p=i.toAffine();return yt(Uint8Array.from([4]),t.toBytes(p.x),t.toBytes(p.y))}),c=e.fromBytes||(m=>{const i=m.subarray(1),u=t.fromBytes(i.subarray(0,t.BYTES)),p=t.fromBytes(i.subarray(t.BYTES,2*t.BYTES));return{x:u,y:p}});function a(m){const{a:i,b:u}=e,p=t.sqr(m),y=t.mul(p,m);return t.add(t.add(y,t.mul(m,i)),u)}if(!t.eql(t.sqr(e.Gy),a(e.Gx)))throw new Error("bad generator point: equation left != right");function f(m){return Mt(m,Z,e.n)}function o(m){const{allowedPrivateKeyLengths:i,nByteLength:u,wrapPrivateKey:p,n:y}=e;if(i&&typeof m!="bigint"){if(Et(m)&&(m=bt(m)),typeof m!="string"||!i.includes(m.length))throw new Error("invalid private key");m=m.padStart(u*2,"0")}let q;try{q=typeof m=="bigint"?m:nt(P("private key",m,u))}catch{throw new Error("invalid private key, expected hex or "+u+" bytes, got "+typeof m)}return p&&(q=_(q,y)),rt("private key",q,Z,y),q}function l(m){if(!(m instanceof w))throw new Error("ProjectivePoint expected")}const B=Nt((m,i)=>{const{px:u,py:p,pz:y}=m;if(t.eql(y,t.ONE))return{x:u,y:p};const q=m.is0();i==null&&(i=q?t.ONE:t.inv(y));const O=t.mul(u,i),I=t.mul(p,i),b=t.mul(y,i);if(q)return{x:t.ZERO,y:t.ZERO};if(!t.eql(b,t.ONE))throw new Error("invZ was invalid");return{x:O,y:I}}),z=Nt(m=>{if(m.is0()){if(e.allowInfinityPoint&&!t.is0(m.py))return;throw new Error("bad point: ZERO")}const{x:i,y:u}=m.toAffine();if(!t.isValid(i)||!t.isValid(u))throw new Error("bad point: x or y not FE");const p=t.sqr(u),y=a(i);if(!t.eql(p,y))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class w{constructor(i,u,p){if(this.px=i,this.py=u,this.pz=p,i==null||!t.isValid(i))throw new Error("x required");if(u==null||!t.isValid(u))throw new Error("y required");if(p==null||!t.isValid(p))throw new Error("z required");Object.freeze(this)}static fromAffine(i){const{x:u,y:p}=i||{};if(!i||!t.isValid(u)||!t.isValid(p))throw new Error("invalid affine point");if(i instanceof w)throw new Error("projective point not allowed");const y=q=>t.eql(q,t.ZERO);return y(u)&&y(p)?w.ZERO:new w(u,p,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(i){const u=t.invertBatch(i.map(p=>p.pz));return i.map((p,y)=>p.toAffine(u[y])).map(w.fromAffine)}static fromHex(i){const u=w.fromAffine(c(P("pointHex",i)));return u.assertValidity(),u}static fromPrivateKey(i){return w.BASE.multiply(o(i))}static msm(i,u){return ye(w,r,i,u)}_setWindowSize(i){N.setWindowSize(this,i)}assertValidity(){z(this)}hasEvenY(){const{y:i}=this.toAffine();if(t.isOdd)return!t.isOdd(i);throw new Error("Field doesn't support isOdd")}equals(i){l(i);const{px:u,py:p,pz:y}=this,{px:q,py:O,pz:I}=i,b=t.eql(t.mul(u,I),t.mul(q,y)),x=t.eql(t.mul(p,I),t.mul(O,y));return b&&x}negate(){return new w(this.px,t.neg(this.py),this.pz)}double(){const{a:i,b:u}=e,p=t.mul(u,zt),{px:y,py:q,pz:O}=this;let I=t.ZERO,b=t.ZERO,x=t.ZERO,E=t.mul(y,y),C=t.mul(q,q),H=t.mul(O,O),L=t.mul(y,q);return L=t.add(L,L),x=t.mul(y,O),x=t.add(x,x),I=t.mul(i,x),b=t.mul(p,H),b=t.add(I,b),I=t.sub(C,b),b=t.add(C,b),b=t.mul(I,b),I=t.mul(L,I),x=t.mul(p,x),H=t.mul(i,H),L=t.sub(E,H),L=t.mul(i,L),L=t.add(L,x),x=t.add(E,E),E=t.add(x,E),E=t.add(E,H),E=t.mul(E,L),b=t.add(b,E),H=t.mul(q,O),H=t.add(H,H),E=t.mul(H,L),I=t.sub(I,E),x=t.mul(H,C),x=t.add(x,x),x=t.add(x,x),new w(I,b,x)}add(i){l(i);const{px:u,py:p,pz:y}=this,{px:q,py:O,pz:I}=i;let b=t.ZERO,x=t.ZERO,E=t.ZERO;const C=e.a,H=t.mul(e.b,zt);let L=t.mul(u,q),U=t.mul(p,O),d=t.mul(y,I),h=t.add(u,p),g=t.add(q,O);h=t.mul(h,g),g=t.add(L,U),h=t.sub(h,g),g=t.add(u,y);let v=t.add(q,I);return g=t.mul(g,v),v=t.add(L,d),g=t.sub(g,v),v=t.add(p,y),b=t.add(O,I),v=t.mul(v,b),b=t.add(U,d),v=t.sub(v,b),E=t.mul(C,g),b=t.mul(H,d),E=t.add(b,E),b=t.sub(U,E),E=t.add(U,E),x=t.mul(b,E),U=t.add(L,L),U=t.add(U,L),d=t.mul(C,d),g=t.mul(H,g),U=t.add(U,d),d=t.sub(L,d),d=t.mul(C,d),g=t.add(g,d),L=t.mul(U,g),x=t.add(x,L),L=t.mul(v,g),b=t.mul(h,b),b=t.sub(b,L),L=t.mul(h,U),E=t.mul(v,E),E=t.add(E,L),new w(b,x,E)}subtract(i){return this.add(i.negate())}is0(){return this.equals(w.ZERO)}wNAF(i){return N.wNAFCached(this,i,w.normalizeZ)}multiplyUnsafe(i){const{endo:u,n:p}=e;rt("scalar",i,G,p);const y=w.ZERO;if(i===G)return y;if(this.is0()||i===Z)return this;if(!u||N.hasPrecomputes(this))return N.wNAFCachedUnsafe(this,i,w.normalizeZ);let{k1neg:q,k1:O,k2neg:I,k2:b}=u.splitScalar(i),x=y,E=y,C=this;for(;O>G||b>G;)O&Z&&(x=x.add(C)),b&Z&&(E=E.add(C)),C=C.double(),O>>=Z,b>>=Z;return q&&(x=x.negate()),I&&(E=E.negate()),E=new w(t.mul(E.px,u.beta),E.py,E.pz),x.add(E)}multiply(i){const{endo:u,n:p}=e;rt("scalar",i,Z,p);let y,q;if(u){const{k1neg:O,k1:I,k2neg:b,k2:x}=u.splitScalar(i);let{p:E,f:C}=this.wNAF(I),{p:H,f:L}=this.wNAF(x);E=N.constTimeNegate(O,E),H=N.constTimeNegate(b,H),H=new w(t.mul(H.px,u.beta),H.py,H.pz),y=E.add(H),q=C.add(L)}else{const{p:O,f:I}=this.wNAF(i);y=O,q=I}return w.normalizeZ([y,q])[0]}multiplyAndAddUnsafe(i,u,p){const y=w.BASE,q=(I,b)=>b===G||b===Z||!I.equals(y)?I.multiplyUnsafe(b):I.multiply(b),O=q(this,u).add(q(i,p));return O.is0()?void 0:O}toAffine(i){return B(this,i)}isTorsionFree(){const{h:i,isTorsionFree:u}=e;if(i===Z)return!0;if(u)return u(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:i,clearCofactor:u}=e;return i===Z?this:u?u(w,this):this.multiplyUnsafe(e.h)}toRawBytes(i=!0){return ct("isCompressed",i),this.assertValidity(),s(w,this,i)}toHex(i=!0){return ct("isCompressed",i),bt(this.toRawBytes(i))}}w.BASE=new w(e.Gx,e.Gy,t.ONE),w.ZERO=new w(t.ZERO,t.ONE,t.ZERO);const S=e.nBitLength,N=pe(w,e.endo?Math.ceil(S/2):S);return{CURVE:e,ProjectivePoint:w,normPrivateKeyToScalar:o,weierstrassEquation:a,isWithinCurveOrder:f}}function Se(n){const e=Ft(n);return dt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Ie(n){const e=Se(n),{Fp:t,n:r}=e,s=t.BYTES+1,c=2*t.BYTES+1;function a(d){return _(d,r)}function f(d){return vt(d,r)}const{ProjectivePoint:o,normPrivateKeyToScalar:l,weierstrassEquation:B,isWithinCurveOrder:z}=xe({...e,toBytes(d,h,g){const v=h.toAffine(),A=t.toBytes(v.x),T=yt;return ct("isCompressed",g),g?T(Uint8Array.from([h.hasEvenY()?2:3]),A):T(Uint8Array.from([4]),A,t.toBytes(v.y))},fromBytes(d){const h=d.length,g=d[0],v=d.subarray(1);if(h===s&&(g===2||g===3)){const A=nt(v);if(!Mt(A,Z,t.ORDER))throw new Error("Point is not on curve");const T=B(A);let j;try{j=t.sqrt(T)}catch(K){const V=K instanceof Error?": "+K.message:"";throw new Error("Point is not on curve"+V)}const M=(j&Z)===Z;return(g&1)===1!==M&&(j=t.neg(j)),{x:A,y:j}}else if(h===c&&g===4){const A=t.fromBytes(v.subarray(0,t.BYTES)),T=t.fromBytes(v.subarray(t.BYTES,2*t.BYTES));return{x:A,y:T}}else{const A=s,T=c;throw new Error("invalid Point, expected length of "+A+", or uncompressed "+T+", got "+h)}}}),w=d=>bt(lt(d,e.nByteLength));function S(d){const h=r>>Z;return d>h}function N(d){return S(d)?a(-d):d}const m=(d,h,g)=>nt(d.slice(h,g));class i{constructor(h,g,v){this.r=h,this.s=g,this.recovery=v,this.assertValidity()}static fromCompact(h){const g=e.nByteLength;return h=P("compactSignature",h,g*2),new i(m(h,0,g),m(h,g,2*g))}static fromDER(h){const{r:g,s:v}=F.toSig(P("DER",h));return new i(g,v)}assertValidity(){rt("r",this.r,Z,r),rt("s",this.s,Z,r)}addRecoveryBit(h){return new i(this.r,this.s,h)}recoverPublicKey(h){const{r:g,s:v,recovery:A}=this,T=I(P("msgHash",h));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");const j=A===2||A===3?g+e.n:g;if(j>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=(A&1)===0?"02":"03",$=o.fromHex(M+w(j)),K=f(j),V=a(-T*K),J=a(v*K),X=o.BASE.multiplyAndAddUnsafe($,V,J);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return S(this.s)}normalizeS(){return this.hasHighS()?new i(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return qt(this.toDERHex())}toDERHex(){return F.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return qt(this.toCompactHex())}toCompactHex(){return w(this.r)+w(this.s)}}const u={isValidPrivateKey(d){try{return l(d),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const d=Kt(e.n);return we(e.randomBytes(d),e.n)},precompute(d=8,h=o.BASE){return h._setWindowSize(d),h.multiply(BigInt(3)),h}};function p(d,h=!0){return o.fromPrivateKey(d).toRawBytes(h)}function y(d){const h=Et(d),g=typeof d=="string",v=(h||g)&&d.length;return h?v===s||v===c:g?v===2*s||v===2*c:d instanceof o}function q(d,h,g=!0){if(y(d))throw new Error("first arg must be private key");if(!y(h))throw new Error("second arg must be public key");return o.fromHex(h).multiply(l(d)).toRawBytes(g)}const O=e.bits2int||function(d){if(d.length>8192)throw new Error("input is too large");const h=nt(d),g=d.length*8-e.nBitLength;return g>0?h>>BigInt(g):h},I=e.bits2int_modN||function(d){return a(O(d))},b=kt(e.nBitLength);function x(d){return rt("num < 2^"+e.nBitLength,d,G,b),lt(d,e.nByteLength)}function E(d,h,g=C){if(["recovered","canonical"].some(D=>D in g))throw new Error("sign() legacy options not supported");const{hash:v,randomBytes:A}=e;let{lowS:T,prehash:j,extraEntropy:M}=g;T==null&&(T=!0),d=P("msgHash",d),Ht(g),j&&(d=P("prehashed msgHash",v(d)));const $=I(d),K=l(h),V=[x(K),x($)];if(M!=null&&M!==!1){const D=M===!0?A(t.BYTES):M;V.push(P("extraEntropy",D))}const J=yt(...V),X=$;function ut(D){const tt=O(D);if(!z(tt))return;const ht=f(tt),ot=o.BASE.multiply(tt).toAffine(),W=a(ot.x);if(W===G)return;const it=a(ht*a(X+W*K));if(it===G)return;let st=(ot.x===W?0:2)|Number(ot.y&Z),et=it;return T&&S(it)&&(et=N(it),st^=1),new i(W,et,st)}return{seed:J,k2sig:ut}}const C={lowS:e.lowS,prehash:!1},H={lowS:e.lowS,prehash:!1};function L(d,h,g=C){const{seed:v,k2sig:A}=E(d,h,g),T=e;return te(T.hash.outputLen,T.nByteLength,T.hmac)(v,A)}o.BASE._setWindowSize(8);function U(d,h,g,v=H){var st;const A=d;h=P("msgHash",h),g=P("publicKey",g);const{lowS:T,prehash:j,format:M}=v;if(Ht(v),"strict"in v)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const $=typeof A=="string"||Et(A),K=!$&&!M&&typeof A=="object"&&A!==null&&typeof A.r=="bigint"&&typeof A.s=="bigint";if(!$&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let V,J;try{if(K&&(V=new i(A.r,A.s)),$){try{M!=="compact"&&(V=i.fromDER(A))}catch(et){if(!(et instanceof F.Err))throw et}!V&&M!=="der"&&(V=i.fromCompact(A))}J=o.fromHex(g)}catch{return!1}if(!V||T&&V.hasHighS())return!1;j&&(h=e.hash(h));const{r:X,s:ut}=V,D=I(h),tt=f(ut),ht=a(D*tt),ot=a(X*tt),W=(st=o.BASE.multiplyAndAddUnsafe(J,ht,ot))==null?void 0:st.toAffine();return W?a(W.x)===X:!1}return{CURVE:e,getPublicKey:p,getSharedSecret:q,sign:L,verify:U,ProjectivePoint:o,Signature:i,utils:u}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function qe(n){return{hash:n,hmac:(e,...t)=>Vt(n,e,oe(...t)),randomBytes:re}}function Ne(n,e){const t=r=>Ie({...n,...qe(r)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Gt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Rt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ae=BigInt(1),xt=BigInt(2),Tt=(n,e)=>(n+e/xt)/e;function Oe(n){const e=Gt,t=BigInt(3),r=BigInt(6),s=BigInt(11),c=BigInt(22),a=BigInt(23),f=BigInt(44),o=BigInt(88),l=n*n*n%e,B=l*l*n%e,z=Y(B,t,e)*B%e,w=Y(z,t,e)*B%e,S=Y(w,xt,e)*l%e,N=Y(S,s,e)*S%e,m=Y(N,c,e)*N%e,i=Y(m,f,e)*m%e,u=Y(i,o,e)*i%e,p=Y(u,f,e)*m%e,y=Y(p,t,e)*B%e,q=Y(y,a,e)*N%e,O=Y(q,r,e)*l%e,I=Y(O,xt,e);if(!St.eql(St.sqr(I),n))throw new Error("Cannot find square root");return I}const St=Ut(Gt,void 0,void 0,{sqrt:Oe}),Le=Ne({a:BigInt(0),b:BigInt(7),Fp:St,n:Rt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=Rt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ae*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),c=t,a=BigInt("0x100000000000000000000000000000000"),f=Tt(c*n,e),o=Tt(-r*n,e);let l=_(n-f*t-o*s,e),B=_(-f*r-o*c,e);const z=l>a,w=B>a;if(z&&(l=e-l),w&&(B=e-B),l>a||B>a)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:z,k1:l,k2neg:w,k2:B}}}},ie);BigInt(0);Le.ProjectivePoint;export{Le as secp256k1};
